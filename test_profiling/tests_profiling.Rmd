---
title: "Profiling"
author: "ROBINE Thomas"
date: "8 juin 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RColorBrewer)
```

# I. Introduction

We do the profiling of the simple case vignette and we want to know which code points take the most time and check that they match the way the code was thought.
Here we test the optimization of a parameter of a USM. We carry out these tests with a repetition number of 2 and a number of assessments of 250 for two reasons. The first being the execution time and the second, the fact that the IDE Rstudio has trouble loading the results of the profiler with too large repetitions and evaluations. Finally, these tests are performed in two configurations, a first sequential configuration and a second using parallelisation with a CPU.

So, we profile our code using the profiling tool from RStudio and we obtaine a flame graph that we analyzed.
Here is the listing of all the calls made after the "model_function" call, that we know their origin. There are many calls that we don't know from what part they are called from.

# II. Calls' path and source

do.call :  SticsOnR/R/stics_wrapper.R#118

do.call -> exists_sticks_exe : SticsOnR/R/stics_wrapper.R#642

do.call -> check_sticks_exe : SticsOnR/R/stics_wrapper.R#642

do.call -> check_sticks_exe -> suppressWarnings : SticsOnR/R/stics_exe_utilities.R#288

do.call -> check_sticks_exe -> suppressWarnings -> run_system_cmd : SticsOnR/R/stics_exe_utilities.R#288

do.call -> check_sticks_exe -> suppressWarnings -> run_system_cmd -> system2 : SticsOnR/R/run_system_cmd.R#19

check_sticks_exe : SticsOnR/R/stics_wrapper.R#131

check_sticks_exe -> suppressWarnings : SticsOnR/R/stics_exe_utilities.R#288

check_sticks_exe -> suppressWarnings -> run_system_cmd : SticsOnR/R/stics_exe_utilities.R#288

check_sticks_exe -> suppressWarnings -> run_system_cmd -> system2 : SticsOnR/R/run_system_cmd.R#19

parallel::makeCluster : SticsOnR/R/stics_wrapper.R#140

parallel::clusterCall : SticsOnR/R/stics_wrapper.R#143

%dopar% : SticsOnR/R/stics_wrapper.R#237

# III. Parallel's runs with 1 USM

![](1usm_thread_method.png)

The "Average run time" column represents the time spent in the call. For example, the time spent in the "do.call -> check_sticks_exe" call is 160 ms whereas in the "check_sticks_exe" call without "do.call", it is 180 ms.

The column "Average global run time" represents the total time spent in the function throughout the program. This is why some functions have an "Average global run time" higher than the function that called it. In this case, the called function was called elsewhere in the program without going through the previous function.

By looking at the calls, we can group them into four parts. The first includes the call to Stics (System2), 
then we have the parts concerning the calls to the cluster and finally the %dopar% part. Moreover, if we sum their percentages,
we arrive at ~ 98%, which agree with the way it was developed.

```{r pie thread, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(16.86,5.81,38.44,37,1.89)
pie(Prop, labels = c("Stics 16.86%","MakeCluster 5.81%","ClusterCall 38.44%","Dopar 37%","Others 1.89%"), border = "white", col = myPalette)
```

# IV. Sequential's runs with 1 USM

![](1usm_sequential_method.png)

```{r pie sequential, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(16.62,5.73,38.32,37.42,1.91)
pie(Prop, labels = c("Stics 16.62%", "MakeCluster 5.73%", "ClusterCall 38.32%", "Dopar 37.42%", "Others 1.91%"), border = "white", col = myPalette)
```