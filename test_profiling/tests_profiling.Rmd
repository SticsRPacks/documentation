---
title: "Profiling"
author: "ROBINE Thomas"
date: "8 juin 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RColorBrewer)
```

# I. Introduction

We do the profiling of the simple case vignette and we want to know which code points take the most time and check that they match the way the code was thought.
Here we test the optimization of a parameter of a USM. We carry out these tests with a repetition number of 2 and a number of assessments of 250 for two reasons. The first being the execution time and the second, the fact that the IDE Rstudio has trouble loading the results of the profiler with too large repetitions and evaluations. Finally, these tests are performed in two configurations, a first sequential configuration and a second using parallelisation with a CPU.

So, we profile our code using the profiling tool from RStudio and we obtaine a flame graph that we analyzed.
Here is the listing of all the calls made after the "model_function" call, that we know their origin. There are many calls that we don't know from what part they are called from.

# II. Calls' path and source

do.call :  SticsOnR/R/stics_wrapper.R#118

do.call -> exists_sticks_exe : SticsOnR/R/stics_wrapper.R#642

do.call -> check_sticks_exe : SticsOnR/R/stics_wrapper.R#642

do.call -> check_sticks_exe -> suppressWarnings : SticsOnR/R/stics_exe_utilities.R#288

do.call -> check_sticks_exe -> suppressWarnings -> run_system_cmd : SticsOnR/R/stics_exe_utilities.R#288

do.call -> check_sticks_exe -> suppressWarnings -> run_system_cmd -> system2 : SticsOnR/R/run_system_cmd.R#19

check_sticks_exe : SticsOnR/R/stics_wrapper.R#131

check_sticks_exe -> suppressWarnings : SticsOnR/R/stics_exe_utilities.R#288

check_sticks_exe -> suppressWarnings -> run_system_cmd : SticsOnR/R/stics_exe_utilities.R#288

check_sticks_exe -> suppressWarnings -> run_system_cmd -> system2 : SticsOnR/R/run_system_cmd.R#19

parallel::makeCluster : SticsOnR/R/stics_wrapper.R#140

parallel::clusterCall : SticsOnR/R/stics_wrapper.R#143

%dopar% : SticsOnR/R/stics_wrapper.R#237

# III. Parallel's runs with 1 USM

![](1usm_thread_method.png)


The "Average run time" column represents the time spent in the call. For example, the time spent in the "do.call -> check_sticks_exe" call is 160 ms whereas in the "check_sticks_exe" call without "do.call", it is 180 ms.

The column "Average global run time" represents the total time spent in the function throughout the program. This is why some functions have an "Average global run time" higher than the function that called it. In this case, the called function was called elsewhere in the program without going through the previous function.

By looking at the calls, we can group them into four parts. The first includes the call to Stics (System2), 
then we have the parts concerning the calls to the cluster and finally the %dopar% part.

```{r pie thread, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(15.37,5.81,38.44,37,3.38)
pie(Prop, labels = c("Check_stics_exe 15.37%","MakeCluster 5.81%","ClusterCall 38.44%","Dopar 37%","Others 3.38%"), border = "white", col = myPalette)
```

# IV. Sequential's runs with 1 USM

![](1usm_sequential_method.png)

```{r pie sequential, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(15.21,5.73,38.32,37.42,3.32)
pie(Prop, labels = c("Check_stics_exe 15.21%", "MakeCluster 5.73%", "ClusterCall 38.32%", "Dopar 37.42%", "Others 3.32%"), border = "white", col = myPalette)
```

# V. Parallel's runs with 7 usms

![](7usms_thread_method.png)

```{r pie thread 7, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(10.29,17.69,30.71,38.83,2.48)
pie(Prop, labels = c("Check_stics_exe 10.29%","MakeCluster 17.69%","ClusterCall 30.71%","Dopar 38.83%","Others 2.48%"), border = "white", col = myPalette)
```

# VI. Sequential's runs with 7 usms

![](7usms_sequential_method.png)

```{r pie sequential 7, echo=FALSE}
myPalette <- brewer.pal(5, "Set2")
Prop <- c(7.81,2.80,17.21,70.76,1.42)
pie(Prop, labels = c("Check_stics_exe 7.81%","MakeCluster 2.80%","ClusterCall 17.21%","Dopar 70.76%","Others 1.42%"), border = "white", col = myPalette)
```

# VII. Conclusion

In conclusion, we can say several things. The first is that the call to the "clusterCall" function can be made once at the beginning of the program. Second, we also observe that optimizing a single USM is not effective because the model takes only one third of the execution time. Finally, we need to distinguish parallels and sequentials runs in order to avoid calling parallels' methods in sequentials' runs and save time.